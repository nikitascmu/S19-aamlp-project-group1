---
title: "ML Pipeline Project Code"
author: "Lauren Rost, Mridul Singh Gangawar, Nikita Setia"
date: "March 19, 2019"
output:
  html_document: default
  pdf_document: default
---

```{r, message=FALSE, warning=FALSE}
#--- Loading helper files 
loadlibs = function(libs) {
  for(lib in libs) {
    class(lib)
    if(!do.call(require,as.list(lib))) {install.packages(lib)}
    do.call(require,as.list(lib))
  }
}
libs = c("tidyr","magrittr","purrr","dplyr","stringr","readr","data.table", "mice", 
         "randomForest", "ada", "gbm", "caret", "e1071", "ROCR", "ggplot2", "readxl",
         "survival", "fastDummies", "DataExplorer", "ggplot2", "corrplot", "ggpubr", "parallel", "doParallel",
         "DMwR", "glmnet")

loadlibs(libs)

mode_fun <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

#--- setting global decimal print setting
options(scipen=4)
source("http://pcwww.liv.ac.uk/~william/R/crosstab.r")

prog = fread("program_activity.csv") %>% as_tibble() 
dem = fread("demographic.csv") %>% as_tibble() 
presc = fread("opiate_prescription_fills.csv") %>% as_tibble()

```

# Data Cleaning
```{r}

summary(dem %>% mutate_if(is.character, as.factor))

```

# Race and Gender Data Cleaning
#### missing data for RACE and GENDER
#### merging native hawaiian/pacific islander + no data = no data and other because the former is too small
#### merging transgendered male to female and no data = no data and other because former is too small
#### dealing with missingness by allowing it to be its own category - because most likely MNAR

```{r}

dem$RACE[which(grepl("No Data", dem$RACE))] = "No Data and Other"
dem$RACE[which(grepl("Native Hawaiian", dem$RACE))] = "No Data and Other"
dem$GENDER[which(grepl("No Data", dem$GENDER))] = "No Data and Other"
dem$GENDER[which(grepl("Transgendered", dem$GENDER))] = "No Data and Other"

dem = dem %>% rename("race"=RACE, "gender"=GENDER)
summary(dem %>% mutate_if(is.character, as.factor))
```


```{r}

summary(prog)

# No missing values in the program data 
# Overdose date and opiate overdose has NAs for individuals who have not overdosed, so that is meaningful and not actually missing

```

# Data Cleaning for Predictor Outcome Variables
```{r}

prog = prog %>% separate(OVERDOSE_DATE, c("OVERDOSE_YEAR", "OVERDOSE_MONTH"), remove=FALSE, sep=4)

prog$OPIATE_OVERDOSE[which(grepl(0, prog$OPIATE_OVERDOSE))] = "Non-Opiate Overdose"
prog$OPIATE_OVERDOSE[which(grepl(1, prog$OPIATE_OVERDOSE))] = "Opiate Overdose"
prog$OPIATE_OVERDOSE[which(is.na(prog$OPIATE_OVERDOSE))] = "No Overdose"

summary(prog %>% mutate_if(is.character, as.factor))


```

```{r}

times_used = prog %>% group_by(PERSON_ID) %>% select(YEAR, MONTH) %>% summarise(times_used = max(sequence(n())))

prog_summary = prog %>% group_by(PERSON_ID) %>% summarise(total_cyfchild = sum(CYFCHILD),
                                                          total_cyfparent = sum(CYFPARENT),
                                                          total_mh = sum(MH),
                                                          total_da = sum(DA),
                                                          total_rx = sum(RX),
                                                          total_acj = sum(ACJ),
                                                          total_cr_cases = sum(MDJS_CR_CASES),
                                                          total_cr_drug_cases = sum(MDJS_CR_DRUG_CASES),
                                                          cohort = min(YEAR),
                                                          od_date = max(OVERDOSE_DATE), 
                                                          od_year = max(OVERDOSE_YEAR), 
                                                          od_month = max(OVERDOSE_MONTH), 
                                                          od_type = max(OPIATE_OVERDOSE))
```

## Data Cleaning: as.factors
```{r}

summary(presc %>% mutate_if(is.character, as.factor))

```

# Data Cleaning: Age
```{r}

age_df = presc %>% group_by(PERSON_ID) %>% summarise(min_age = min(AGE), max_age = max(AGE), mean_age = round(mean(AGE)))

age_df = age_df %>% group_by(PERSON_ID) %>% mutate(age_clean = if_else(min_age<0, max_age, min_age)) %>%
  mutate(age_clean = if_else(age_clean<0, 999, age_clean))

age_df$age_clean[which(age_df$age_clean>99)] = NA
age_df$age = age_df$age_clean
age_df$age[which(is.na(age_df$age_clean))] = median(age_df$age_clean, na.rm=TRUE)

summary(age_df)
```

# Data Cleaning: Drug Information 
```{r}

presc$drug_strength <- str_extract(presc$LABEL_NAME, "[0-9].*")

# drug strength indicated that these are oral solutions per 5ML, so made this change manually
presc$drug_strength[which(grepl('ORAL SOLUTION', presc$extract_strength))] <- "5-325/5ML"
presc$drug_strength[which(grepl('NALOXONE', presc$LABEL_NAME))] <- "50MG-0.5MG"
presc = presc %>% mutate(drug_strength = if_else(is.na(drug_strength), DRUG_STRENGTH, drug_strength))

# Creating a new column 'num_strength' that keeps only numeric values from 'drug_strength'
presc$num_strength <- str_extract(presc$drug_strength, "[0-9]*.*[0-9]")

presc <- separate(presc, num_strength, c("opioid_strength", "compound_strength"), sep = '-')
presc <- separate(presc, opioid_strength, c("opioid", "divisor"), sep = '/')
presc$opioid <- str_extract(presc$opioid, "[0-9]*.*[0-9]")
presc <- separate(presc, compound_strength, c("compound", "divisor2"), sep = '/')
#sum(presc$divisor==presc$divisor2,na.rm=TRUE)
presc = presc %>% mutate(divisor = if_else(is.na(divisor), divisor2, divisor))
presc = presc %>% select(-divisor2)
presc = presc %>% mutate(opioid = if_else(is.na(compound), opioid, 
                                                  if_else(opioid>compound, compound, opioid)))
presc$divisor[which(is.na(presc$divisor))] = 1
presc$compound[which(is.na(presc$compound))] = 1

presc = presc %>% mutate(opioid_converted = as.numeric(opioid)/as.numeric(divisor))

```

# Data Cleaning: Drug Information, Continued
```{r}

presc <- presc %>% 
  mutate(conversion_factor = 
    if_else(grepl('BUPRENORPHINE', GENERIC_NAME) & grepl('PATCH', DOSAGE_FORM_DESC), 12.6, 
    if_else(grepl('BUPRENORPHINE', GENERIC_NAME) & grepl('AMPUL', DOSAGE_FORM_DESC), 30,
    if_else(grepl('BUTORPHANOL', GENERIC_NAME), 7,
    if_else(grepl('CODEINE', GENERIC_NAME), 0.15,
    if_else(grepl('DIHYDROCODEINE BITARTRATE', GENERIC_NAME), 0.25,
    if_else(grepl('OPIUM', GENERIC_NAME), 1,
    if_else(grepl('FENTANYL', GENERIC_NAME) & grepl('TABLET', DOSAGE_FORM_DESC), 0.13,
    if_else(grepl('FENTANYL', GENERIC_NAME) & grepl('LOZENGE', DOSAGE_FORM_DESC), 0.13,
    if_else(grepl('FENTANYL', GENERIC_NAME) & grepl('PATCH', DOSAGE_FORM_DESC), 7.2,
    if_else(grepl('NALBUPHINE', GENERIC_NAME), 1,
    if_else(grepl('FENTANYL CITRATE', GENERIC_NAME), 0.13,
    if_else(grepl('HYDROCODONE', GENERIC_NAME), 1,
    if_else(grepl('HYDROMORPHONE', GENERIC_NAME), 4,
    if_else(grepl('LEVORPHANOL TARTRATE', GENERIC_NAME), 11,
    if_else(grepl('MEPERIDINE', GENERIC_NAME), 0.1,
    if_else(grepl('METHADONE', GENERIC_NAME) & opioid_converted<=20, 4, 
    if_else(grepl('METHADONE', GENERIC_NAME) & opioid_converted>20, 8, 
    if_else(grepl('MORPHINE', GENERIC_NAME), 1, 
    if_else(grepl('OXYCODONE', GENERIC_NAME), 1.5, 
    if_else(grepl('OXYMORPHONE', GENERIC_NAME), 3,
    if_else(grepl('PENTAZOCINE', GENERIC_NAME), 0.37,
    if_else(grepl('TAPENTADOL', GENERIC_NAME), 0.4,
    if_else(grepl('TRAMADOL', GENERIC_NAME), 0.1, 0))))))))))))))))))))))))

```

# Data Cleaning: Drug Information, Continued

```{r}

#presc %>% group_by(generic_name) %>% summarise(count = n()) %>% arrange(count)
presc <- presc %>% 
  mutate(generic_name = 
    if_else(grepl('DIHYDROCODEINE BITARTR', presc$GENERIC_NAME), 'DIHYDROCODEINE BITARTRATE', 
    if_else(grepl('BUPRENORPHINE', presc$GENERIC_NAME), 'BUPRENORPHINE',
    if_else(grepl('HYDROCODONE BITARTRAT', presc$GENERIC_NAME), 'HYDROCODONE BITARTRATE',
    if_else(grepl('MORPHINE SULFATE', presc$GENERIC_NAME), 'MORPHINE SULFATE',
    if_else(grepl('OXYCODONE', presc$GENERIC_NAME), 'OXYCODONE', 
    if_else(grepl('PENTAZOCINE', presc$GENERIC_NAME), 'PENTAZOCINE',
    if_else(grepl('TRAMADOL', presc$GENERIC_NAME), 'TRAMADOL',
    if_else(grepl('CODEINE PHOSPHATE', presc$GENERIC_NAME), 'CODEINE PHOSPHATE',
    if_else(grepl('OPIUM/BELLADONNA', presc$GENERIC_NAME), 'OPIUM/BELLADONNA', 
    if_else(grepl('FENTANYL', presc$GENERIC_NAME), 'FENTANYL',
    if_else(grepl('HYDROMORPHONE', presc$GENERIC_NAME), 'HYDROMORPHONE', 
    if_else(grepl('MEPERIDINE', presc$GENERIC_NAME), 'MEPERIDINE', GENERIC_NAME
    )))))))))))))


presc <- presc %>% 
  mutate(dosage_form = 
    if_else(grepl('TABLET', presc$DOSAGE_FORM_DESC), 'PILL', 
    if_else(grepl('VIAL', presc$DOSAGE_FORM_DESC), 'VIAL',
    if_else(grepl('SYRINGE', presc$DOSAGE_FORM_DESC), 'VIAL',
    if_else(grepl('CAPSULE', presc$DOSAGE_FORM_DESC), 'PILL', 
    if_else(grepl('PATCH', presc$DOSAGE_FORM_DESC), 'PATCH',
    if_else(grepl('LOZENGE', presc$DOSAGE_FORM_DESC), 'LOZENGE',
    if_else(grepl('AMPUL', presc$DOSAGE_FORM_DESC), 'AMPUL',
    if_else(grepl('SPRAY', presc$DOSAGE_FORM_DESC), 'SPRAY',
    if_else(grepl('SOLUTION', presc$DOSAGE_FORM_DESC), 'LIQUID',
    if_else(grepl('LIQUID', presc$DOSAGE_FORM_DESC), 'LIQUID',
    if_else(grepl('CONCENTRATE', presc$DOSAGE_FORM_DESC), 'LIQUID',
    if_else(grepl('SUPPOSITORY', presc$DOSAGE_FORM_DESC), 'SUPPOSITORY', 'NA'
    )))))))))))))
```

## Data Cleaning: Days Supply
```{r}

loop_values = presc %>% group_by(generic_name, dosage_form) %>% summarise(count = n())

generics = loop_values[[1]]
dosages = loop_values[[2]]

min_supply_vec=rep(0, length(generics))
max_supply_vec=rep(0, length(generics))
min_dispensed_vec=rep(0, length(generics))
max_dispensed_vec=rep(0, length(generics))

for (i in 1:length(generics)){
  presc_subset = presc %>% filter(generic_name==generics[i] & dosage_form==dosages[i])
  min_supply_vec[i]=round(quantile(presc_subset$DAYS_SUPPLY , probs=seq(0, 1, by=0.005))[[2]])
  max_supply_vec[i]=round(quantile(presc_subset$DAYS_SUPPLY, probs=seq(0, 1, by=0.005))[[200]])
  
  min_dispensed_vec[i]=round(quantile(presc_subset$DISPENSED_QTY , probs=seq(0, 1, by=0.005))[[5]])
  max_dispensed_vec[i]=round(quantile(presc_subset$DISPENSED_QTY, probs=seq(0, 1, by=0.005))[[195]])
}

min_supply_vec = min_supply_vec %>% as.data.frame()
min_supply_vec = min_supply_vec %>% rename(min_supply_val = ".")
max_supply_vec = max_supply_vec %>% as.data.frame()
max_supply_vec = max_supply_vec %>% rename(max_supply_val = ".")

min_dispensed_vec = min_dispensed_vec %>% as.data.frame()
min_dispensed_vec = min_dispensed_vec %>% rename(min_dispensed_val = ".")
max_dispensed_vec = max_dispensed_vec %>% as.data.frame()
max_dispensed_vec = max_dispensed_vec %>% rename(max_dispensed_val = ".")

values = bind_cols(loop_values, min_supply_vec)
values = bind_cols(values, max_supply_vec)
values = bind_cols(values, min_dispensed_vec)
values = bind_cols(values, max_dispensed_vec)
values = values %>% select(-count)

presc = merge(presc, values, all.x = TRUE, key=c("generic_name, dosage_form"))

presc = presc %>% mutate(days_supply = if_else(DAYS_SUPPLY<min_supply_val, as.integer(min_supply_val), 
                                           if_else(DAYS_SUPPLY>max_supply_val, as.integer(max_supply_val),
                                                   as.integer(DAYS_SUPPLY))))

presc = presc %>% mutate(dispensed_qty = if_else(DISPENSED_QTY<min_dispensed_val,
                                                       as.integer(min_dispensed_val), 
                                           if_else(DISPENSED_QTY>max_dispensed_val, 
                                                   as.integer(max_dispensed_val),
                                                   as.integer(DISPENSED_QTY))))

```


```{r}

#unique(presc$conversion_factor)

presc$mme <- round((presc$opioid_converted*presc$dispensed_qty*presc$conversion_factor)/presc$days_supply,2)

# quantile(presc$mme, probs=seq(0, 1, by=0.005))
```



```{r, warning=FALSE, message=FALSE}

presc_summary = presc %>% group_by(PERSON_ID) %>% summarise(num_presc = n(), 
                                            most_presc_drug = mode_fun(generic_name),
                                            oxy_count = sum(grepl('OXYCODONE', generic_name)),
                                            tram_count = sum(grepl('TRAMADOL', generic_name)),
                                            hydrobit_count = sum(grepl('HYDROCODONE BITARTRATE', generic_name)),
                                            most_dose_form = mode_fun(dosage_form),
                                            pill_count = sum(grepl('PILL', dosage_form)),
                                            patch_count = sum(grepl('PATCH', dosage_form)),
                                            liquid_count = sum(grepl('LIQUID', dosage_form)),
                                            avg_mme = round(mean(mme)),
                                            median_mme = round(median(mme)),
                                            mode_mme = round(mode_fun(mme)),
                                            avg_supply = round(mean(days_supply)),
                                            avg_dispensed = round(mean(dispensed_qty)))

final_data = merge(dem, age_df %>% select(PERSON_ID, age), all.x = TRUE, all.y = TRUE, key="PERSON_ID")
final_data = merge(final_data, prog_summary, all.x = TRUE, all.y = TRUE, key="PERSON_ID")
final_data = merge(final_data, presc_summary, all.x = TRUE, all.y = TRUE, key="PERSON_ID")

summary(final_data %>% mutate_if(is.character, as.factor))

```


## ** End Data Cleaning **

# Machine Learning Analysis
```{r}

table(final_data$od_type)

final_data_df <- final_data %>% 
        mutate(mme_group = ifelse(avg_mme %in% 1:99 ,"1.<100",
                           ifelse(avg_mme %in% 100:249 ,"2.100-249", 
                           ifelse(avg_mme %in% 250:999 ,"3.250-999",
                           ifelse(avg_mme %in% 1000:4999 ,"4.1000-4999","5.>5000+")))))

crosstab(final_data, row.vars = "most_presc_drug",col.vars = "od_type", type = "f", addmargins = FALSE)
crosstab(final_data_df, row.vars = "mme_group",col.vars = "od_type", type = "f", addmargins = FALSE)
crosstab(final_data, row.vars = "race",col.vars = "od_type", type = "f", addmargins = FALSE)
crosstab(final_data, row.vars = "cohort",col.vars = "od_type", type = "f", addmargins = FALSE)
crosstab(final_data, row.vars = "most_dose_form",col.vars = "od_type", type = "f", addmargins = FALSE)

rm(final_data_df)
```

### Some drugs and dosage form counts have very few counts so there is no need to keep them as a separate category. Here we create a separate category for "Other" in which we combine all such categories.

```{r}
final_data <- group_category(data = final_data, feature = "most_presc_drug", threshold = 0.002, update = TRUE) %>%
            group_category(feature = "most_dose_form", threshold = 0.0002, update = TRUE)

crosstab(final_data, row.vars = "most_presc_drug",col.vars = "od_type", type = "f", addmargins = FALSE)
crosstab(final_data, row.vars = "most_dose_form",col.vars = "od_type", type = "f", addmargins = FALSE)
```


```{r pressure, echo=FALSE}
#correlation matrix between numerical variables
corr_data_num <- final_data[,c(4,5,6,7,8,9,10,11,12,18,20,21,22,24,25,26,27,30,31)]
res <- cor(corr_data_num)
corrplot(res, type = "upper", order = "hclust", tl.col = "black", tl.srt = 45)
```

```{r}
c1 <- ggplot(final_data, aes(avg_mme)) + labs(x="Average Morphine Milligram Equivalents (MME)", y="Count") + geom_histogram(fill="#336B87",breaks=c(seq(100,6000, by=150)))
c2 <- ggplot(final_data, aes(median_mme)) + labs(x="Median MME", y="Count") + geom_histogram(fill="#336B87",breaks=c(seq(100,6000, by=150)))
c3 <- ggplot(final_data, aes(mode_mme)) + labs(x="Mode MME", y="Count") + geom_histogram(fill="#336B87",breaks=c(seq(100,6000, by=150)))
ggarrange(c1,c2,c3,nrow=3,ncol=1)
rm(list=c('c1','c2','c3'))
```

### median_mme looks normal and less skewed. We will be using median_mme for prediction purpose. Also, we remove columns that are related to overdose date, for this column is a proxy for the target variable and is not available in the future dataset. 

```{r}

final_data$target <- NULL
final_data$target[final_data$od_type=='No Overdose'] <- 0
final_data$target[final_data$od_type=='Non-Opiate Overdose'] <- 0
final_data$target[final_data$od_type=='Opiate Overdose'] <- 1

final_data <- final_data %>% select(-c('avg_mme','mode_mme','od_date','od_year','od_type','od_month','PERSON_ID'))

trans <- function(x){
  return (log(1+x))
}


#dummifying data to create dummy categorical variables
final_df <- final_data %>% select(-c(target))
final_df <- dummify(final_df)
final_df <- final_df  %>% mutate_all(funs(trans))
final_df$target <- final_data$target

```


# Multivariate Logistic Regression
```{r}

smp_size <- floor(0.5 * nrow(final_df))
set.seed(1)
train_indices <- sample(seq_len(nrow(final_df)),size=smp_size)

xtrain <- final_df[train_indices,]
xtest <- final_df[-train_indices,] 

xtrain$target <- factor(xtrain$target)
xtest$target <- factor(xtest$target)

model_logistic <- glm (target~., data=xtrain, family = binomial,control = list(maxit = 50))

## Predict the Values
predict_logistic <- predict(model_logistic, xtest, type = 'response')

## Create Confusion Matrix
table(xtest$target, predict_logistic > 0.4)


```

####Due to the fact that we were not able to capture a single opioid overdose case with logistic regression, we attempt to identify opioid overdose cases using SMOTE (Synthetic Minority Oversampling Technique).

# Logistic Regression with Oversampling

```{r}
options(scipen=999)

#Logistic Regression with Oversampling

set.seed(1)
balanced.data <- SMOTE(target ~., xtrain, perc.over = 500, k = 5, perc.under = 500)
as.data.frame(table(balanced.data$target))

cluster <- makeCluster(detectCores() - 1) # convention to leave 1 core for OS
registerDoParallel(cluster)

fitControl <- trainControl(method = "cv", number = 5, allowParallel = TRUE)

fit <- train(target ~ ., method="rf",data=balanced.data,trControl = fitControl)

var.imp <- varImp(fit)
plot(var.imp,top=15)
```


# Multivariate Logistic Regression on Selected Features (using Cross-Validation)

```{r}

cols_to_select = c("tram_count","total_da","race_White","total_cr_drug_cases","median_mme","total_cr_cases",
                   "race_Black.African.American","avg_dispensed","most_presc_drug_OXYMORPHONE.HCL","gender_Male","gender_Female",
                   "avg_supply","age","total_mh","total_acj","pill_count",
                   "num_presc","hydrobit_count","oxy_count","most_presc_drug_HYDROCODONE.BITARTRATE","target")

xtrain <- xtrain[,c(cols_to_select)]
xtest <- xtest[,c(cols_to_select)]
balanced.data <- balanced.data[,c(cols_to_select)]


fitControl <- trainControl(method = "repeatedcv",number = 5,repeats = 3)

model_logistic_cv <- train(target ~ ., data = balanced.data, method = "glm",family = binomial(link = "logit"),
                          trControl = fitControl)


#predicted values for testdata:
pred_logistic_cv <- predict(model_logistic_cv$finalModel,xtest,type = 'response')

#test with confusion matrix
table(pred_logistic_cv>0.4,xtest$target)

#quantile(pred_balanced_logistic_cv, probs = seq(0, 1, by= 0.1))
```

# Ridge Regression (using Cross-Validation)

```{r}
set.seed(123) 

y = balanced.data$target %>% as.matrix()
x = balanced.data %>% select(-c(target))   %>% as.matrix()

cv.lasso <- cv.glmnet(x, y, alpha = 0.1, family = "binomial",nfolds=10,type.measure = "auc")
model_ridge <- glmnet(x, y, alpha = 1, family = "binomial",lambda = cv.lasso$lambda.min)

# Make predictions on the test data
x.test <- xtest %>% select(-c(target)) %>% as.matrix()
pred_ridge <- model_ridge %>% predict(newx = x.test)

table(pred_ridge>0.2,xtest$target)
```

# Random forest (using Cross-Validation)

```{r}

fitControl <- trainControl(method = "cv", number = 5, allowParallel = TRUE)

model_rf <- train(target ~ ., method="rf",data=balanced.data,trControl = fitControl)

pred_rf <- predict(model_logistic_cv$finalModel,xtest,type = 'response')
table(pred_rf>0.3,xtest$target)
```

# Gradient Boosting Machine (using Cross-Validation)

```{r}

set.seed(123)
fitControl = trainControl(method="cv", number=5, returnResamp = "all",allowParallel = TRUE)

model_gbm = train(target~., data=balanced.data, method="gbm",distribution="bernoulli", trControl=fitControl, verbose=F, tuneGrid=data.frame(.n.trees=5000, .shrinkage=0.1, .interaction.depth=1, .n.minobsinnode=1))

pred_gbm <- predict(model_gbm,xtest,type = 'prob')

table(pred_gbm$'1'>0.2,xtest$target)

stopCluster(cluster)
registerDoSEQ()
```

# AdaBoost 

```{r}

library(ada)

model_ada = ada(formula = target ~ .,data=balanced.data ,iter=10)

pred_ada <- predict(model_ada,xtest,type = 'prob')

table(pred_ada[,2]>0.2,xtest$target)
```

# Neural Network 
```{r}
library(keras)
# Neural net

balanced.data2 <- SMOTE(target ~., xtrain, perc.over = 4800, k = 5, perc.under = 2400)


y_train <- as.numeric(balanced.data2$target) %>% as.matrix()
y_test <- as.numeric(xtest$target) %>% as.matrix()

x_train <- balanced.data2 %>% select(-c(target)) %>% as.matrix()
x_test <- xtest %>% select(-c(target)) %>% as.matrix()

model_nn <- keras_model_sequential() 
model_nn <- model_nn %>% 
  layer_dense(units = 256, activation = 'tanh', input_shape = c(20)) %>% 
  layer_dropout(rate = 0.4) %>% 
  layer_dense( units= 256, kernel_initializer = "uniform", activation = "tanh") %>%
  layer_dropout(0.1) %>%
  layer_dense(units = 64, activation = 'relu') %>%
  layer_dropout(rate = 0.3) %>%
  layer_dense(units = 1, activation = 'softmax')

model_nn %>% compile(
  loss = 'binary_crossentropy',
  optimizer = optimizer_rmsprop(),
  metrics = c('accuracy')
)

history <- model_nn %>% fit(
  x_train, y_train, 
  epochs = 50, batch_size = 128, 
  validation_split = 0.2
)

pred_model_nn = model_nn %>% predict(x_test)
table(pred_model_nn,xtest$target)

``` 

# Evaluation of Machine Learning Methods
```{r}
library(pROC)

roc(xtest$target,pred_logistic_cv,plot=TRUE,legacy.axes=TRUE, col="#377eb8",print.auc=TRUE,percent = TRUE,print.auc.y=60,
    xlab="False Positive Rate",ylab="True Positive Rate")
plot.roc(xtest$target,pred_ridge, col="#4daf4a",print.auc=TRUE,add=TRUE,percent=TRUE, print.auc.y=50)
plot.roc(xtest$target,pred_rf, col="#FF420E",print.auc=TRUE,add=TRUE,percent=TRUE,print.auc.y=40)
plot.roc(xtest$target,pred_gbm$'1', col="#FFBB00",print.auc=TRUE,add=TRUE,percent=TRUE,print.auc.y=30)
plot.roc(xtest$target,pred_ada[,2], col="#763626",print.auc=TRUE,add=TRUE,percent=TRUE,print.auc.y=20)
plot.roc(xtest$target,pred_model_nn, col="#375E97",print.auc=TRUE,add=TRUE,percent=TRUE,print.auc.y=10)

legend("bottomright",legend=c("Logistic regression (LR)","Ridge LR","Random Forest","Gradient Boosting","AdaBoost","Neural Network"),
            col=c("#377eb8","#4daf4a","#FF420E","#FFBB00","#763626","#375E97"),lwd=4, bg=F)

```


### Survival Analysis

```{r 2009 Cohort}

#most overdoses occur in the 2009 cohort, so makes sense to examine this one
#prog %>% group_by(cohort) %>% summarise(od = sum(OPIATE_OVERDOSE!="No Overdose"))

prog = prog %>% group_by(PERSON_ID) %>% mutate(cohort=min(YEAR))
prog_cohort2009 = prog %>% filter(cohort==2009)

paste("There are", length(unique(prog_cohort2009$PERSON_ID)), "individuals in the 2009 Cohort")

prog_cohort2009$year_month <- (as.integer(prog_cohort2009$YEAR)%%2009)*12+as.integer(prog_cohort2009$MONTH)

prog_cohort2009$od_year_month <- (as.integer(prog_cohort2009$OVERDOSE_YEAR)%%2009)*12+as.integer(prog_cohort2009$OVERDOSE_MONTH)

prog_cohort2009 = prog_cohort2009 %>% group_by(PERSON_ID) %>% mutate(min_yearmonth=min(year_month))
#prog_cohort2009 = prog_cohort2009 %>% filter(min_yearmonth==1)

survival_data = prog_cohort2009 %>% group_by(PERSON_ID) %>% summarise(time_yearmonth = max(year_month), 
                                                      od_time = max(od_year_month))
survival_data = survival_data %>% mutate(status = if_else(is.na(od_time), 0, 1))
survival_data = survival_data %>% mutate(time = if_else(is.na(od_time), time_yearmonth, od_time))
survival_data = survival_data %>% select(PERSON_ID, status, time)
survival_data = merge(survival_data, dem, key="PERSON_ID")
survival_data = merge(survival_data, age_df %>% select(PERSON_ID, age), key="PERSON_ID")

#plot 1
km = Surv(survival_data$time, survival_data$status) %>%
  (function(x) survfit(x ~ 1, data=survival_data))(.)
# Kaplan-Meier curve
plot(km, xlab= "Months",ylab="P(survive)", mark.time=T)
km

#plot 2 (by gender)
km_gender = survfit(Surv(survival_data$time, survival_data$status) ~ gender, data=survival_data)
plot(km_gender,
     col=c(1:3), mark.time = T); legend("bottomleft", c("Female","Male", "No Data & Other"), col=1:3, lty=c(1,1))
km_gender

#analysis by age
km_age = survfit(Surv(survival_data$time, survival_data$status) ~ age<45, data=survival_data)
km_age

#didn't make sense to plot this.. so just showing output
km_race = survfit(Surv(survival_data$time, survival_data$status) ~ race, data=survival_data)
km_race

```

# Cox Proportional Hazards Model

```{r 2009 cohort cox}

cm = Surv(survival_data$time, survival_data$status) %>%
  (function(x) coxph(x ~ age + gender, data=survival_data))(.)
cm

#for 2009 cohort, being male increases hazard (coefficient)
#for 2009 cohort, men have 77% greater hazard compared to women??
#this is a statistically significant difference

#controlling for gender, age increases hazard (coefficient)
#1 year increase in age increases hazard by 2.6% controlling for gender??
#this is statistically significant and makes sense

### Regularized Cox model
cox_data = survival_data %>% select(-time, -status, -PERSON_ID) %>% as.data.frame() %>% as.matrix()
cox_data = cox_data %>% dummy_cols(c("gender", "race"))
cox_data = cox_data %>% select(-gender, -race) %>% as.data.frame() %>% as.matrix()

lm = glmnet(cox_data, Surv(survival_data$time, survival_data$status), family="cox")
plot(lm)

#How to choose s? Consider sparsity you want with cross-validation
cvlm = cv.glmnet(cox_data, Surv(survival_data$time, survival_data$status), family="cox")
plot(cvlm)

coef(lm, s=cvlm$lambda.min)
coef(lm, s=cvlm$lambda.1se)

```

